## 自我介绍

> 面试官您好,我叫 xxx,20xx 年毕业于 xx 大学,至今有 x 年的前端开发经验,之前工作中自已主要参与开发过 pc 端 toB,移动端 h5 业务
> 使用技术栈主要是 vue 对 vue 底层源码也有过相关的了解,使用 UI 框架主要过 Element,antd,Echarts
> 自己工作之余也喜欢看一些大佬的书籍和博客,比如阮一峰老师周刊和开发者手册,曾探(tan)老师的 javascript 设计模式与开发实践,掘金黄轶老师的 vue 的源码讲解,
> 我的自我介绍完毕了,谢谢面试官

## 项目难点

### 星云平台

1. 流水线打包部署(重点: 打包优化)

- 前端通常打包,是通过`npm run build`生成 dist 目录,压缩通过`xftp 或 xshell`上传到服务器发布,但对于有还有规范检验的,在多个环境频繁打包的就显得麻烦了,所以通过流水线部署,通过关联代码仓库,设定门禁系统(全量和增量),可信规范(codecheck 检测),安全测试,多个环境一站式部署,可以设置定时发布,生成质量报告

- 打包优化
  1. 通过`npm run build --report`导出`report.html`打包分析文件
  2. `externals`,大的不打包'vue echarts vue-router axios',使用内部 CDN 引入
  3. 组件库按需加载,'使用 cdn,失去按需加载,必须引入所有 js 和 css',使用插件
  4. 使用`split-chunks`,提取重复代码,动态导入,按需加载`babel-plugin-component`
  5. 使用`thread-loader`多线程打包`terser-webpack-plugin`,主要针对`babel eslint`的 js
  6. 使用 gzip 压缩

2.  代码错误收集和上报

- 区分错误类型:`接口异常` 和 `代码逻辑异常`
- 接口异常
  1. 请求失败;获取响应,错误状态,在 axios 拦截器中统一处理
- 代码逻辑异常
  1. 逻辑错误,js 语法造成,vue 提供了`app.config.errorHandler`
  2. 错误对象,触发错误组件,错误的信息(生命周期钩子)

3.  日志文件过大(文件上传)

- Blob.prototype.slice,并发多个,记录顺序
- 封闭 xhr,返回 Promise
- 切片 10M,放入 formData 中,使用 Promise.all 并发上传
- 进度条
  1. 单个切片上传进度,整个文件上传进度
  2. 监听 upload.onprogress,工厂函数,返回不同的监听函数
  3. 总进度条,单个切片累计/整个文件大小,使用 vue 的计算属性
- 断点续传
  1. 内容生成 hash,库`spark-md5`,文件过大,`UI阻塞,页面假死`,使用`web worker`解决,`postMessage`发送进度
  2. 暂停:xhr 对象保存成`requestList`,上传成功删除,调用`abort`方法,取消请求
  3. 恢复上传:调用接口,返回已传的切片,跳过切片,filter 过滤
- 文件秒传
  1. 上传前,计算出 hash,发给服务端,找到,返回成功
- Bug 处理
  1. 点击暂停清空 xhr 请求,点击恢复,重新创建了 xhr 导总进度条`倒退`
  2. `假进度条`,基于总文件进度条,只会`停止和增加`
  3. `vue监听属性`,真的增加也`增加`,真的的减少就`暂停`

4.  Echarts 不更新

- resize()
- 'transiton' 'transitionstart' 和 'transitionend'
- 'setInterval'
- 窗口不会触发,依然需要监听 'window.resize'
- DOM 属性和节点变化检测`MutationObserver`,DOM 尺寸变化`ResizeObserver`

```
const ro = new ResizeObserver(cb)
ro.observer(el)
```

- 返回一个`contentRect`

5.  vue 升级 vue3 Table 加载变慢

- vue3 性能优化减少了`85%`渲染耗时(6.88s 减少到 1s)
  1. 工作中要把一处重要模块从 vue2 升级到 vue3,升级后发现 element-plus 性能相比于 vue2 严重下降
  2. 表格是`50行*300列的`,自定义两列一列选择框,一列开关,在切换开关时,`600-700ms下降到5-6s`,严重影响用户体验
- 优化内容
- 修改 table 源码,将 data 与 columns 从 ref 改为`shallowRef`(性能减少了 17%-20%)
  1. 当时发现这个问题后,我们先去看了 table 的源码,发现传入的 table 参数`data 与 columns`都是使用 ref 进行响应式转换的
  2. 这边又去查阅了 vue3 官方文档,发现说的一个对象赋值给 ref,这个对象通过`reactive`转为`深层次响应式的对象`,包含了嵌套的 ref,深层的解包,性能消耗是比较大的,要避免`深层次的转换`使用`shallowRef`
  3. `shallowRef`是`浅层次作用`,仅当`xx.value`变更时,才触发更新,`减少深层次依赖,提升patch对比性能`
  4. 副作用,修改之后会不会对之前的功能有影响
  - 我们每次列表数据更新,业务逻辑都会去请求列表设置`list.value===xxx`是可以正常触发 shallowRef 更新的
  - 经过我们测试,switch 开关`v-model绑定的scope.row.status`变更也是正常的
  - 手动点击`选中,排序,分页`都没有影响
  - 当然,这种修改肯定 d 不影响之前的业务前提下修改,修改之后,要多加测试,对之前有影响,就要换种方法
- 源码中`getColspanRealWidth`函数响应式数据优化(性能提高 7%-20%,函数耗时 200ms 下降到 7ms)
  1. 当页面卡顿时,我们通过 devtool 的`performance面板`测试性能,我们录制一个`switch开关切换`性能数据,发现在 main 中的有两个带红色`longtask`长任务,1.89+1.73,整体耗时 3.5s 左右,我们点击观察对应的`火焰图`,发现紫色小块`Render`比较耗时,点击 render,在底部详情里面通过`bottom-up`和`call tree`中,发现一个函数`getColspanRealWidth`耗时 200ms 比较严重,通过右侧的`source map`跳到对应源码进行分析
  2. 发现,函数依赖的参数是响应式的,我们对这个参数通过一个函数返回,处理为`非响应式的`,修改为测试,函数耗时从`200ms到1ms`,render 性能提升
- 代码业务逻辑进行优化(2.7s 到 0.5s)
  1. 经过上面的优化后,意识到,`很细微的呚式数据优化也会对性能带来较大的影响`,这同样适用于业务逻辑中
  2. 采用注释加替换静态节点的方法,找到具体哪里耗时,然后针对优化
  3. 自定义列中`el-tooltip`换成静态节点后,性能有大的提升.有 performance 面板看到 patch 基本没有了,编译成静态节点,更新不用对比了
  4. 基于这个思路,el-tooltip 组件会成倍的增加 patch 比对耗时,那我们减少它的数量就能提高性能
  5. 原本之前业务 el-tooltop 使用了 disabled 属性用于隐藏 tooltop,但元素还是会渲染,我们修改为`v-if`,减少了元素渲染,测试发现达到 0.5s 刷新
- 通过这次优化,自己也学到了很多东西
  1. 在分析性能时,自己要多借用 performance 面板工具对应录制分析,自己也可以写一个性能耗时逻辑做对比,有数据参数.对组件的耗时,可以借助 vue-devtool 查看组件更新渲染耗时,排查响应式数据问题
  2. 业务场景代码时,自己要采用`注释+静态节点替换`排查耗时比较长的逻辑,针对性优化
- 反问: 不使用虚拟列表
  1. 虚拟列表不够丝滑,不支持横向滚动,我们的 table 做了顶部固定,和底部滚动优化,里面改动非常大轻易替换非常麻烦,所以花了长时间优化

6.  事件对筛选

### h5 智慧 APP6.0

1. 封装组件过程

2. 超过 2000 条卡顿(虚拟列表)

- 时间分片
  1. 卡顿是同时渲染大量 DOM 引起的,将渲染过程分批进行
  2. 使用 `setTimeout 分段加载`,加载速度提升了,快速滚动时出现`白屏和闪屏`
     - `闪屏原因:`
     - 执行时间不确定,宏任务的,主线程执行完了,才会执行它,实际执行时间会比设定的慢
     - fps 受屏幕分辨率和屏幕尺寸影响,不同设备刷新频率可能不同,setTimeout 只能设置固定时间
     - 对 dom 操作,必须等到屏幕下次绘制,`两者步调不一致,导致某一帧跨过去,直接更新下一帧,导致丢帧`
  3. 使用`requestAnimationFrame` 和 `DocumentFragment`
     - 由系统决定回调函数执行机制,`屏幕每一次刷新间隔只执行一次,滚动流畅不会闪烁丢帧`
     - 内存中 dom,插入时不会引起页面回流,append 时只插入子元素不带本身
     - 只针对大量简单 dom 插入,我们账单列表比较复杂,插入时性能表现还是不够理想
- 长列表渲染

  1. performance 分析消耗时间最多是`Recalculate style 样式计算`和`Layout布局`
  2. 只加载`可视区域`的列表项,滚动时动态计算获取`可视区域`,把`非可视区域`列表删除

  ```
    // html
    <div class="viewport">
      <div class="bar"></div>
      <div class="list"></div>
    </div>

    1. 视口相对定位,list相对定位
    2. 计算出视口,能加载的列表数量
    3. 通过视口scrollTop / 账单列表高度,计算属性动态初始和终止,list.slice()获得需要加载的数据
    4. 发现,相对定位也会发生上移,通过list.transform设置translateY滚动条顶部的高度,平移下来
    5. 实现 长列表滚动


  ```

  3. 监听`scroll事件`会频繁触发,造成`重复计算`,使用`intersectionObserver`替换,出现可视区域才会`异步触发对应回调函数`性能消耗极低

- 经过测试,在旧的手机上 iphone4s 运行也比较流畅,没有出现卡顿闪屏现象

3. ios vedio 标签时间轴不显示

4. 金币抛洒效果

5. 折叠屏手机布局错乱

6. 首屏优化过程

### 代码性能分析

1. 前端规范制定

2. monaco-editor 选中代码,页面变长

3. monaco-editor 打包体积优化

4. 两栏布局, 拖动过快出现卡顿 和失效
