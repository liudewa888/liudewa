## 自我介绍

> 面试官您好,我叫 xxx,20xx 年毕业于 xx 大学,至今有 x 年的前端开发经验,之前工作中自已主要参与开发过 pc 端 toB 业务`星云平台`,移动端 h5 业务`智慧金融APP6.0`,
> 自己使用的技术栈主要是 vue,vue2/3 都有过使用,对底层源码也有过相关的了解,使用 UI 框架有 Element,antd,可视化图表库使用过 Echarts,d3.js
> 自己工作之余喜欢看一些大佬的书籍和博客,比如`阮一峰老师周刊和开发者手册`,`掘金黄轶老师的 vue 的源码讲解`,
> 也经常去`B站`和`极客时间`学习自己感兴趣前端技术
> 我的自我介绍完毕了,谢谢面试官

## 项目难点

### 星云平台

1. 流水线打包部署(重点: 打包优化)

- 前端通常打包,是通过`npm run build`生成 dist 目录,压缩通过`xftp 或 xshell`上传到服务器发布,但对于有还有规范检验的,在多个环境频繁打包的就显得麻烦了,所以通过流水线部署,通过关联代码仓库,设定门禁系统(全量和增量),可信规范(codecheck 检测),安全测试,多个环境一站式部署,可以设置定时发布,生成质量报告

- 打包优化
  - 打包速度优化
    1. oneof 打包过程中每个文件都到经过所有 loader 处理,虽然正则没有匹配,但还是要过一遍就比较慢,使用 oneof,只要匹配一个剩下不匹配了
    2. 开启 cache 打包过程中,主要对 js 进行打包,都要经过 EsLint 检查和 babel 编译,缓存它们之前的结果,第二次打包就会快
    3. 多进程打包 thread-loader,打包主要文件是 js,处理 js 文件的主要有 eslint,babel 三个,要提升它们的运行速度,开启多进程同时处理 js,使用 thread-loader
  - 打包体积优化
    1. 使用 webpack-bundle-anizlay-plugin 对打包资源进行分析
    2. 静态资源,视频和图片使用了 webp 对于不兼容使用压缩后的 png,经过压缩直接放到服务器的 public 中
    3. 使用 externals 提取公共依赖包,比如'vue axios echarts',并使用内部 cdn 进行引入
    4. 组件库 element 使用按需引入,如果使用 extranals 失去按需引入功能,只需加载组件和对应的样式
    5. Babel 为编译的文件插入了辅助代码,'@babel/plugin-transform-runtime',禁用 babel 对每个文件注入,使辅助代码从这里用
    6. 'compression-webpack-plugin' 进行 gzip 压缩

2. 埋点监控系统 SDK 实现代码错误收集和上报

- 数据采集
- 用户行为收集(pv uv 事件操作)

  1. 起初,每次点击都请求接口收集,后续随着需要埋点事件越来越多,不易管理
  2. 自动收集基本事件,手动调用方法,可以通过`公共参数` 和 `挂载标签属性`传递参数

- 页面性能收集
  1. performance.timing,performance.getEntriesByName('first-contentful-paint')
  2. 项目引入的`同步`资源
  3. 项目引入的`异步`资源
- 错误异常收集

1. 我们写了一个通用的错误采集函数,这个函数参数传入 type,error(原生:错误对象行列,堆栈;组件:错误对象,触发错误组件,错误来源(生命周期))对象
2. 什么时间收集
   1. 原生错误
   - try-catch
   - error
   - 异步错误 promise.reject unhandledrejection
   2. 组件错误
   - vue 提供组件生命周期钩子 errorCaptured 可以对组件错误进行捕获,
   - 我们项目中采用,配置全局的 app.config.errorHandler,进行捕获
   3. 接口错误
   - 前期项目中使用的是 axios,就采用了 axios 提供了拦截函数 intercpetor(axios.interceptors.response.use())
   - 后续其他项目使用了 fetch,后面修改使用 XMLHttpRequest.prototype.send 进行监听

- 数据上报
  - 使用 sendBeacon 发送,不兼容的使用 new image 进行兜底
  1. 降级 new Image()使用 1x1 gif 图片,没有跨域限制
  - 使用图片原因:没有跨域限制,不用特殊处理;静态页面可能会禁用 js 了
  - 为什么使用 gif 图片,是 1 X 1 像素下,gif 图片的大小是最小的
  2. 提供了打点标记 sendBeacon 优先使用 navigator.sendBeacon 发送数据
  - 不会和主业务抢占资源,浏览器空闲发送
  - 页面卸载时也保证请求成功发送,不阻塞页面刷新和跳转

3. 复杂表格组件

- 业务中使用了很多表格,使用 json 生成表格
- 表格可以分布, 多选(复选框), 顶部新增,删除,行尾操作,行可以编辑
- 使用表格插槽,开发每一行的按钮;样式调整顶部按钮,表格,分布条的布局;监听分布事件更新表格数据;顶部按钮要获取表格数据,需要调用表格提供 api;行编辑的需求,要通过插槽渲染编辑的内容,要控制行编辑的开关
- 为了满足团队的快速开发,对上面进行了封装,只需配置对应 json 便可以完成以上功能
  1. 基础配置,组件给了 columns 和 data 属性,默认显示复选框,配置 selectable 属性关闭
  2. 添加分页,current-page page-size,total,默认页面变化时自动同步页码,同时添加 page-change 事件
  3. 添加顶部按钮,表格上面会有新增,删除,搜索框;buttons 属性 ,添加;通过 before 属性控制显示,disabled 配置禁用
  4. 行尾添加按钮,像设置,下载,按钮添加 actions 属性;会冻结到表格最右侧,不会随滚动条滚动
  5. 行编辑功能, 使用 row-key 字段
  6. 指定字段为链接
- 封装
  1. 整个表格分为三部分,顶部按钮区, 中间表格区, 底部分布
  2. 表格列区分为: 常规,行编辑, 操作按钮,插槽,链接列
  3. 行编辑支持 input ,select inputNumber TimeSelect

4. 日志文件过大(文件上传)

- Blob.prototype.slice,并发多个,记录顺序
- 封闭 xhr,返回 Promise
- 切片 10M,放入 formData 中,使用 Promise.all 并发上传
- 进度条
  1. 单个切片上传进度,整个文件上传进度
  2. 监听 upload.onprogress,工厂函数,返回不同的监听函数
  3. 总进度条,单个切片累计/整个文件大小,使用 vue 的计算属性
- 断点续传
  1. 内容生成 hash,库`spark-md5`,文件过大,`UI阻塞,页面假死`,使用`web worker`解决,`postMessage`发送进度
  2. 暂停:xhr 对象保存成`requestList`,上传成功删除,调用`abort`方法,取消请求
  3. 恢复上传:调用接口,返回已传的切片,跳过切片,filter 过滤
- 文件秒传
  1. 上传前,计算出 hash,发给服务端,找到,返回成功
- Bug 处理
  1. 点击暂停清空 xhr 请求,点击恢复,重新创建了 xhr 导总进度条`倒退`
  2. `假进度条`,基于总文件进度条,只会`停止和增加`
  3. `vue监听属性`,真的增加也`增加`,真的的减少就`暂停`

5. vue 升级 vue3 Table 加载变慢

- vue3 性能优化减少了`85%`渲染耗时(6.88s 减少到 1s)
  1. 工作中要把一处重要模块从 vue2 升级到 vue3,升级后发现 element-plus 性能相比于 vue2 严重下降
  2. 表格是`50行*300列的`,自定义两列一列选择框,一列开关,在切换开关时,`600-700ms下降到5-6s`,严重影响用户体验
- 优化内容
- 修改 table 源码,将 data 与 columns 从 ref 改为`shallowRef`(性能减少了 17%-20%)
  1. 当时发现这个问题后,我们先去看了 table 的源码,发现传入的 table 参数`data 与 columns`都是使用 ref 进行响应式转换的
  2. 这边又去查阅了 vue3 官方文档,发现说的一个对象赋值给 ref,这个对象通过`reactive`转为`深层次响应式的对象`,包含了嵌套的 ref,深层的解包,性能消耗是比较大的,要避免`深层次的转换`使用`shallowRef`
  3. `shallowRef`是`浅层次作用`,仅当`xx.value`变更时,才触发更新,`减少深层次依赖,提升patch对比性能`
  4. 副作用,修改之后会不会对之前的功能有影响
  - 我们每次列表数据更新,业务逻辑都会去请求列表设置`list.value===xxx`是可以正常触发 shallowRef 更新的
  - 经过我们测试,switch 开关`v-model绑定的scope.row.status`变更也是正常的
  - 手动点击`选中,排序,分页`都没有影响
  - 当然,这种修改肯定不影响之前的业务前提下修改,修改之后,要多加测试,对之前有影响,就要换种方法
- 源码中`getColspanRealWidth`函数响应式数据优化(性能提高 7%-20%,函数耗时 200ms 下降到 7ms)
  1. 当页面卡顿时,我们通过 devtool 的`performance面板`测试性能,我们录制一个`switch开关切换`性能数据,发现在 main 中的有两个带红色`longtask`长任务,1.89+1.73,整体耗时 3.5s 左右,我们点击观察对应的`火焰图`,发现紫色小块`Render`比较耗时,点击 render,在底部详情里面通过`bottom-up`和`call tree`中,发现一个函数`getColspanRealWidth`耗时 200ms 比较严重,通过右侧的`source map`跳到对应源码进行分析
  2. 发现,函数依赖的参数是响应式的,我们对这个参数通过一个函数返回,处理为`非响应式的`,修改为测试,函数耗时从`200ms到1ms`,render 性能提升
- 代码业务逻辑进行优化(2.7s 到 0.5s)
  1. 经过上面的优化后,意识到,`很细微的呚式数据优化也会对性能带来较大的影响`,这同样适用于业务逻辑中
  2. 采用注释加替换静态节点的方法,找到具体哪里耗时,然后针对优化
  3. 自定义列中`el-tooltip`换成静态节点后,性能有大的提升.有 performance 面板看到 patch 基本没有了,编译成静态节点,更新不用对比了
  4. 基于这个思路,el-tooltip 组件会成倍的增加 patch 比对耗时,那我们减少它的数量就能提高性能
  5. 原本之前业务 el-tooltop 使用了 disabled 属性用于隐藏 tooltop,但元素还是会渲染,我们修改为`v-if`,减少了元素渲染,测试发现达到 0.5s 刷新
- 通过这次优化,自己也学到了很多东西
  1. 在分析性能时,自己要多借用 performance 面板工具对应录制分析,自己也可以写一个性能耗时逻辑做对比,有数据参数.对组件的耗时,可以借助 vue-devtool 查看组件更新渲染耗时,排查响应式数据问题
  2. 业务场景代码时,自己要采用`注释+静态节点替换`排查耗时比较长的逻辑,针对性优化
- 反问: 不使用虚拟列表
  1. 虚拟列表不够丝滑,不支持横向滚动,我们的 table 做了顶部固定,和底部滚动优化,里面改动非常大轻易替换非常麻烦,所以花了长时间优化

6. 首屏优化

- 原则
  - 2-5-8 原则,5 接受 8 糟糕,争 1 保 2
- 性能监测(google web-vitals)

  1. FCP(first contentful paint)内容呈现到屏幕上: 页面开始->任何内容呈现(文本,图像)
     - performance.getEntriesByName('first-contentful-paint')[0].startTime - performance.timing.navigationStart
  2. LCP(Largest Contentful Paint)视口内最大可见内容渲染时间: 页面开始->最大内容呈现
     - performance.getEntriesByName('largest-contentful-paint')[0].startTime - performance.timing.navigationStart
  3. FID(first input delay)首次输入延时:用户第一次交互到实际开始处理
  4. CLS(cumulative layout shift)布局偏移

- 方法

  1. performance.timing,performance.getEntries(),performanceObserver;前端实现页面性能监控就是使用 ap 进行收集的
  2. performance 面板工具条,总览图(fps,cpu,net),火焰图(timings,network,frames,main),总体报告(summary:rendering paint,script;bottom-up(事件时长排序);calltree(调用栈):通过尾部行跳转到对应源代码)
  3. lighthouse 工具; performance 列出 fcp lcp fid cls 时间 同时给出优化方案;seo;pwa;

- 解决过程
  1. static 大图使用 webp 图片,体积只有 png 的 1/3,小图使用 svg
  2. 页面路由开启按需加载
  3. ui 库按需引入
  4. 优化分包使用 splitchunks 通过设置 chunks,minSize, cacheGroups;
  5. 打包和 nignx 服务器开启 gzip 压缩
  6. 使用 Prefech 预请求
  7. 静态资源到托管公司内部 cnd 上

7. Echarts 踩坑

- resize()
- 'transiton' 'transitionstart' 和 'transitionend'
- 'setInterval'
- 窗口不会触发,依然需要监听 'window.resize'
- DOM 属性和节点变化检测`Mutation Observer`,DOM 尺寸变化`ResizeObserver`

```
const ro = new ResizeObserver(cb)
ro.observer(el)
```

- 返回一个`contentRect`

- tooptip

8. 水印功能的实现

- 页面覆盖一个 position:fixed 的 div 盒子,透明度设置为 0.2,设置 pointer-events:none 样式实现点击穿透,在盒子内通过 js 循环生成小的水印 div,div 内显示水印内容
  1. 由于 js 循环创建了多个 dom 元素,性能不理想
- 使用 canvas 输出背景图:页面覆盖一个 position:fixed 盒子,创建一个 canvas 画布,绘制一个水印区域,通过 canvas.toDataURL 方法输出一个图片,通过 backgrou-image 将这个图片设置为盒子的背景图,background-repeat:repeat 实现填满整个页面的效果
- 由于是在前端添加水印的,对于小白是有用的,但对于有前端知识的,可以通过开发者工具的审查元素面板定位到元素进行删除,对于这个问题,我一开始想到的办法是通过设置一个定时器,每隔几秒种就检查水印元素是否存在,如果发生变化,再执行一次覆盖水印的方法.但这种方式,利用定时器频繁检查,性能不理想
- 在掘金上查阅文章,发现,可以利用'Mutation Observer'API 来监视 DOM 变动,这个 API 可以监听的 DOM 的子节点的增减,属性变动,文本内容变动;只能监听子节点变化,对于自身被删除,没有办法被监听,通过监听父节点来实现,监听到变化就执行覆盖水印的方法

- 显性水印 和 隐性水印
  1. 图片加载后画到 canvas 中,在 canvas 中绘制水印,通过 canvas.toDataUrl()获得 base64 并替换原来的图片路径
  2. canvas.getImageData()

### h5 智慧金融 APP6.0

1. 封装组件过程(金额输入控件)

- 属性
  - type 组件类型(rmb,美元)
  - clientKeybord 是否调用客户端键盘 (系统键盘,自带键盘)
  - dataRoleRegex 验证规则
  - dataRoleRegexMsg 错误提示 (不符合规则进行提示)
  - placeholder 占位符
  - maxlength 最大长度
  - clear 是否清除图标显示
  - disabled 是否禁用
  - readonly 是否只读
  - name 表单绑定的值
  - digits 保留小数后多少位
- 事件
  - change 输入值变化
  - focus 聚焦
  - blur 失焦

2. 超过 2000 条卡顿(虚拟列表)

- 时间分片
  1. 卡顿是同时渲染大量 DOM 引起的,将渲染过程分批进行
  2. 使用 `setTimeout 分段加载`,加载速度提升了,快速滚动时出现`白屏和闪屏`
     - `闪屏原因:`
     - 执行时间不确定,宏任务的,主线程执行完了,才会执行它,实际执行时间会比设定的慢
     - fps 受屏幕分辨率和屏幕尺寸影响,不同设备刷新频率可能不同,setTimeout 只能设置固定时间
     - 对 dom 操作,必须等到屏幕下次绘制,`两者步调不一致,导致某一帧跨过去,直接更新下一帧,导致丢帧`
  3. 使用`requestAnimationFrame` 和 `DocumentFragment`
     - 由系统决定回调函数执行机制,`屏幕每一次刷新间隔只执行一次,滚动流畅不会闪烁丢帧`
     - 内存中 dom,插入时不会引起页面回流,append 时只插入子元素不带本身
     - 只针对大量简单 dom 插入,我们账单列表比较复杂,插入时性能表现还是不够理想
- 长列表渲染

  1. performance 分析消耗时间最多是`Recalculate style 样式计算`和`Layout布局`
  2. 只加载`可视区域`的列表项,滚动时动态计算获取`可视区域`,把`非可视区域`列表删除

  ```
    // html
    <div class="viewport">
      <div class="bar"></div>
      <div class="list"></div>
    </div>

    1. 视口相对定位,list相对定位
    2. 计算出视口,能加载的列表数量
    3. 通过视口scrollTop / 账单列表高度,计算属性动态初始和终止,list.slice()获得需要加载的数据
    4. 发现,相对定位也会发生上移,通过list.transform设置translateY滚动条顶部的高度,平移下来
    5. 实现 长列表滚动


  ```

  3. 监听`scroll事件`会频繁触发,造成`重复计算`,使用`intersectionObserver`替换,出现可视区域才会`异步触发对应回调函数`性能消耗极低

- 经过测试,在旧的手机上 iphone4s 运行也比较流畅,没有出现卡顿闪屏现象

3. ios video 标签时间轴不显示

4. 金币抛洒效果

- 存钱罐刚开始页面是静态的,产品经理让加动画,自己想了两种方案
  1. 使用 gif
     - 第一种使用 gif 动图,默认给一张静态图,当用户下滑到存钱罐时,用动态图替换,动效完毕后,再把图片用静态图替换掉来实现
     - 存在 2 个问题,1 是首先切换图片时,会出现`闪屏`,当时通过定时器,延时解决了
     - 2 是,gif 图片是循环播放的,在页面第一次动画时,是正常的,当第二次时,就出现动画错乱了,最后查找原因,发现首次加载图片后,浏览器会缓存图片,下次切换时,由于是从缓存中拿到的,图片一直循环动画,第二次动画开始的时间就不确定了,形成了错乱,最后把图片元素删除再重新 append,解决了这个问题
     - 最后,每次要删除图片,再 append,不能利用浏览器缓存,浪费性能,最后,决定自己实现动画
  2. 使用 animation 动画
     - 定时器 + Math.sin + cos (正弦 余弦),设置 bottom left 坐标
     - animation-timing-function steps 函数 起点和终点(简单,帧数少效果不流畅)
     - 取抛物线坐标上点, 效果流畅(算坐标比较麻烦)
     - 贝塞尔曲线

5. 折叠屏手机布局错乱

- 宽度问题
  1. 宝贝任务页面由于页面采用 flex+rem 布局,我们开发时,是以 750px 为标准开发的,把根元素的 font-size 设置为 50px,就是 15 份
  2. 在折叠屏展开时,整个页面变宽,采用 flex 布局,主轴设置为`space-bettween`,和剩余空间变行感觉大,看起来丑陋
  3. 我们通过设置`媒体查询`,当屏幕宽度大于 960 时,我们就把 font-size 固定为 50px,意思屏幕最大支持 960px,实现居中
- 高度问题(橡皮筋问题)
  1. 宝贝任务页面,要下滑到存钱罐,但在 ios 会存`橡皮筋效果`,整个 app 顶部都会跟着下滑,当时通过查找资料,发现要禁用`touchmove`事件
  2. 但是,高度是超出屏幕高度的,底部的账户信息需要下滑才能看到,由于禁止了,所以不能滑动,导致信息不能完全显示
  3. 在普通手机,经过高度发现`宽/高`比例是大于 1.5 时,整个屏幕信息可以显示完整,但折叠屏手机的宽高比例小于 1,因为是以宽度划分为 15 份,于是通过计算小于 1.5 时,就把高度平分 15 份作为根元素的 font-size,当离开宝贝任务页面时,再恢复过来就解决了

6. 首屏优化过程

### VSCode + web 端

1. 前端规范制定

2. 轮询获得最新的分析结果,效率低下

3. monaco-editor 打包体积优化

- 先总体再优化
  - 打包后的 monaoc-editor 体积占一半,严重影响加载速度
  - 业务层面,只用到展示功能,语言编辑功能完全用不到,
  - 默认是支持所有语言的,我们只要五种主流语言,这些都要去掉,使用`monaco-editor-webpack-plugin`,按需引入需要的语言包
  - 重量级的,通过 webpack 的 splitChunks 功能拆分为单独文件,充分利用浏览器缓存
  - 加载,需要`代码高度`页面才需要加载
  - 开启`prefetch`预加载,在浏览器空闲时预先下载资源
- 先简单再叠加
  - 提供了`editor.api`引入,最基础的版本,没有`高亮,代码提示,折叠,右键`功能
  - 再分别引入对应包`主要语言,高亮,代码提示,折叠和代码格式化,代码联想`功能

4. 两栏布局, 拖动过快出现卡顿 和 失效

### BI 数据可视化看板系统(移动端)
